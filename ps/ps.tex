\documentclass[CJKutf8,dvipsnames,table]{beamer}
\usepackage{hyperref}
\hypersetup{
  pdftitle={Operating System Concepts},
  pdfauthor={Hong MingJian},
  pdfsubject={Process Synchronization},
  pdfpagemode={FullScreen},
  colorlinks={true},
  linkcolor={blue},
}

%% https://tex.stackexchange.com/questions/47576/combining-ifxetex-and-ifluatex-with-the-logical-or-operation
\usepackage{ifxetex,ifluatex}
\newif\ifxetexorluatex % a new conditional starts as false
\ifnum 0\ifxetex 1\fi\ifluatex 1\fi>0
   \xetexorluatextrue
\fi
\usepackage{ifplatform}
\ifxetexorluatex
	\usepackage[slantfont,boldfont]{xeCJK}
	\ifwindows
		\setCJKmainfont{SimSun} % Windows默认中文字体：中易宋体
	\fi
	\ifmacosx
		\setCJKmainfont{STSong} % MacOS默认中文字体：华文宋体
	\fi
	\iflinux
		\setCJKmainfont{Noto Serif CJK SC} % Linux默认中文字体：思源宋体(By Adobe & Google)
	\fi
\else
	\usepackage{CJKutf8}
\fi

\usepackage{listings}
\lstset{
	language=[ANSI]C,
	basicstyle=\scriptsize,
	tabsize=2,
	breaklines=true,
	keywordstyle=\color{blue},
	identifierstyle=,
	commentstyle=\color{OliveGreen},
	stringstyle=,
	showstringspaces=false,
  extendedchars=false
%  numbers=left,
%  numberstyle=\tiny
}

\usetheme{Madrid}%{Warsaw}
\usecolortheme{crane}

%gets rid of bottom navigation bars
\setbeamertemplate{footline}[page number]{}
%gets rid of navigation symbols
\setbeamertemplate{navigation symbols}{}

\begin{document}
\ifxetexorluatex\else
\begin{CJK*}{UTF8}{song}
\fi

  \title{操作系统原理}
  \subtitle{第七章：进程同步}
  \author{洪明坚}
  \institute{重庆大学软件学院}
  \date{\today}

  \AtBeginSection[]
  {
    \begin{frame}
      \frametitle{Outline}
      \tableofcontents[currentsection]
    \end{frame}
  }

  \frame{\titlepage}

  \frame{\frametitle{目录}\tableofcontents}

\section{Race condition}

  %% PAGE
  \begin{frame}
  \frametitle{Background} \pause
  \begin{itemize}
  \item Cooperating processes may share a block of memory via IPC facilities provided by the kernel.  \pause
    \begin{itemize}
    \item Multiple threads within a process may share a piece of memory by using global variables.  \pause
    \end{itemize}
  \item Concurrent access to shared data may result in data inconsistency.  \pause
    \begin{itemize}
    \item Maintaining data consistency requires mechanisms to ensure the orderly execution of cooperating processes.  \pause
    \end{itemize}
  \item Solution to \emph{producer and consumer problem} (Chapter 4) allows at most \textit{(BSIZE - 1)} items in buffer at the same time.  \pause
    \begin{itemize}
    \item A solution, where all \textit{BSIZE} buffers are used is NOT simple.  \pause
    \item Suppose that we modify the code by adding a variable \textit{counter}. 
    \end{itemize}
  \end{itemize}
  \end{frame}

  %% PAGE
  \begin{frame}[fragile]
  \frametitle{Producer and consumer problem} \pause
  \begin{itemize}
  \item Shared-memory bounded-buffer  \pause
  \end{itemize}
\begin{lstlisting}
                   /* Shared variables */
                   #define BSIZE 10
                   struct item {
                      ....
                   } buffer[BSIZE];
                   int in = 0, out = 0, counter = 0;
/*---------------------------------------------------------------*/
/*The producer loop*/                 /*The consumer loop*/
while(1) {                            while(1) {
  /*produce an item*/                   while(counter == 0)
  while(counter == BSIZE)                 /*do nothing*/;
    /*do nothing*/;                     itemConsumed = buffer[out];
  buffer[in] = itemProduced;            out = (out + 1) % BSIZE;
  in = (in + 1) % BSIZE;                counter--;
  counter++;                            /*consume the item*/
}                                     }
\end{lstlisting}
\end{frame}

  %% PAGE
  \begin{frame}[fragile]
  \frametitle{Problem of above solution (1/2)} \pause
  \begin{itemize}
  \item When producer and consumer processes are executed \emph{concurrently}, they may not function correctly.  \pause
    \begin{itemize}
    \item We can show that the value of \textit{counter} may be incorrect as follows.  \pause
    \end{itemize}
  \item Note that the ``\textit{counter}$++$'' and ``\textit{counter}$--$'' may be implemented in machine language as  \pause
  \end{itemize}

\begin{lstlisting}
        ; counter++
        register1 = counter        ; load the counter to a register
        register1 = register1 + 1  ; add
        counter = register1        ; write back

        ; counter--
        register2 = counter        ; load the counter to a register
        register2 = register2 - 1  ; subtract
        counter = register2        ; write back
\end{lstlisting}

\end{frame}

  %% PAGE
  \begin{frame}
  \frametitle{Problem of above solution (2/2)} \pause
  \begin{itemize}
  \item It's important to note that the above two instruction sequences can be \emph{interleaved} because of interrupts or scheduling.  \pause
  \item For example, assume \textit{counter} is initially 5,  \pause
  \end{itemize}
  \rowcolors[]{1}{blue!20}{blue!10}
  \begin{tabular}{c|c|c|c}
    Time & Producer                & Consumer              & result\\
    \hline \pause
    $T_0$   & register1=\textit{counter}       &                       & \{register1=5\}\\ \pause
    $T_1$   & register1=register1+1   &                       & \{register1=6\}\\ \pause
    $T_2$   &                         & register2=counter     & \{register2=5\}\\ \pause
    $T_3$   &                         & register2=register2-1 & \{register2=4\}\\ \pause
    $T_4$   & \textit{counter}=register1       &                       & \{\textit{counter}=6\}\\   \pause
    $T_5$   &  & \textit{counter}=register2     & \{\textit{counter}=\color{red}4\color{black}\}     \pause
  \end{tabular}
  \begin{itemize}
  \item The value of \textit{counter} may be either 4 or 6, while the correct result should be 5. 
  \end{itemize}
  \end{frame}

  %% PAGE
  \begin{frame}
  \frametitle{Questions}
  \begin{itemize}
  \item Any questions? 
  \end{itemize}
  \begin{center}
    \includegraphics[scale=.5]{question}
  \end{center}
  \end{frame}

  %% PAGE
  \begin{frame}
  \frametitle{Race condition (1/2)} \pause
  \begin{itemize}
  \item \emph{Race condition is a situation where several processes access and manipulate the same data concurrently and the outcome of the execution depends on the particular order in which the access takes place}.  \pause
  \item How do we avoid race condition?  \pause
    \begin{itemize}
    \item Find some way to prohibit more than one process from reading and writing the shared data concurrently.  \pause
    \item That is, the access must be \emph{serialized} even if the processes attempt concurrent access. 
    \end{itemize}
  \end{itemize}
  \end{frame}

  %% PAGE
  \begin{frame}
  \frametitle{Race condition (2/2)} \pause
  \begin{itemize}
  \item \textbf{Critical section}  \pause
    \begin{itemize}
    \item a piece of code where the shared resource is accessed.  \pause
    \end{itemize}
  \item A solution of race condition must satisfy the following 4 requirements:  \pause
    \begin{enumerate}
    \item \textbf{Mutual exclusion}: No two process may be simultaneously inside their critical section;  \pause
    \item \textbf{Progress}: No process running outside its critical section may block other processes trying to enter its critical section;  \pause
    \item \textbf{Bounded waiting}: No process should have to wait forever to enter its critical section;  \pause
    \item \textbf{Speed}: No assumptions may be made about speeds or the number of the CPUs. 
    \end{enumerate}
  \end{itemize}
  \end{frame}

  %% PAGE
  \begin{frame}[fragile]
  \frametitle{Critical section} \pause
  \begin{itemize}
  \item A protocol must be designed to be used by the processes to enter and leave critical section.  \pause
    \begin{itemize}
    \item Each process must request permission to enter its critical section.  \pause
    \end{itemize}
  \end{itemize}

\begin{lstlisting}
                        do {
                          <entry section>

                          CRITICAL SECTION

                          <exit section>

                        } while (1);
\end{lstlisting}

  \pause

  \begin{itemize}
  \item{In the following slides, we will try to construct several ``entry
    section'' and ``exit section'' to solve the race condition.}
  \end{itemize}
\end{frame}

  %% PAGE
  \begin{frame}
  \frametitle{Questions}
  \begin{itemize}
  \item Any questions? 
  \end{itemize}
  \begin{center}
    \includegraphics[scale=.5]{question}
  \end{center}
  \end{frame}

\section{Possible solutions to race condition}

\subsection{Software solutions}

  %% PAGE
  \begin{frame}[fragile]
  \frametitle{First try} \pause
  \begin{itemize}
  \item Assume there are only two cooperating processes: $P_i$ and $P_j$, where i+j=1.  \pause
  \end{itemize}

\begin{lstlisting}
                   int turn = 0; // or 1
                   do {
                     while(turn != i);  // entry section

                     CRITICAL SECTION

                     turn = j;          // exit section

                   } while (1);
\end{lstlisting}

  \begin{itemize}
  \item Does it satisfy all 4 requirements for a solution?  \pause
    \begin{itemize}
    \item No, it breaks the \textbf{progress} requirement. 
    \end{itemize}
  \end{itemize}
\end{frame}

  %% PAGE
  \begin{frame}[fragile]
  \frametitle{Second try} \pause

\begin{lstlisting}
                   bool flag[2] = {false, false};
                   do {
                     // entry section
                     flag[i] = true;
                     while(flag[j]);

                     CRITICAL SECTION

                     flag[i] = false; // exit section

                   } while (1);
\end{lstlisting}

  \begin{itemize}
  \item Does it satisfy all 4 requirements for a solution?  \pause
    \begin{itemize}
    \item No, it breaks the \textbf{progress} requirement too. 
    \end{itemize}
  \end{itemize}
\end{frame}

  %% PAGE
  \begin{frame}[fragile]
  \frametitle{Third try} \pause

\begin{lstlisting}
                   int turn = 0; // or 1
                   bool flag[2] = {false, false};
                   do {
                     // entry section
                     flag[i] = true;
                     turn = j;
                     while(flag[j] && turn == j);

                     CRITICAL SECTION

                     flag[i] = false; // exit section

                   } while (1);
\end{lstlisting}

  \begin{itemize}
  \item Does it satisfy all 4 requirements for a solution?  \pause
    \begin{itemize}
    \item Yes, it's a correct solution and is known as \emph{Peterson's algorithm}. 
    \end{itemize}
  \end{itemize}
\end{frame}

  %% PAGE
  \begin{frame}[fragile]
  \frametitle{Bakery algorithm} \pause
  \begin{itemize}
  \item Peterson's algorithm solves the problem for two processes, while \emph{Bakery algorithm} solves it for multiple processes.  \pause
  \end{itemize}

\begin{lstlisting}
          bool choosing[n] = {false, ..., false};
          int number[n] = {0, ..., 0};
          do {
            // entry section
            choosing[i] = true;
            number[i] = max(number[0], ..., number[n-1])+1;
            choosing[i] = false;
            for(j=0; j < n; j++) {
              while(choosing[j]);
              while((number[j]!=0)&&(number[j],j)<(number[i],i));
            }

            CRITICAL SECTION

            number[i] = 0; // exit section

          } while (1);
\end{lstlisting}

\end{frame}

  %% PAGE
  \begin{frame}
  \frametitle{Questions}
  \begin{itemize}
  \item Any questions? 
  \end{itemize}
  \begin{center}
    \includegraphics[scale=.5]{question}
  \end{center}
  \end{frame}

\subsection{Hardware solutions}

  %% PAGE
  \begin{frame}
  \frametitle{Synchronization hardware} \pause
  \begin{itemize}
  \item Several low-level hardware features may be used to solve the race condition.  \pause
    \begin{enumerate}
    \item Disabling interrupts  \pause
    \item Special instructions  \pause
      \begin{itemize}
      \item TSL (Test and Set Lock)  \pause
      \item SWAP 
      \end{itemize}
    \end{enumerate}
  \end{itemize}
  \end{frame}

  %% PAGE
  \begin{frame}
  \frametitle{Disabling interrupts} \pause
  \begin{itemize}
  \item The CPU is only switched from process to process as a result of clock or other interrupts.  \pause
    \begin{itemize}
    \item Once a process has disabled interrupts, it can access the shared memory without fear that any other process will intervene.  \pause
    \end{itemize}
  \item Example - INTEL x86  \pause
    \begin{itemize}
	\item CLI (\textbf{cl}ear \textbf{i}nterrupt) - turn off interrupt  \pause
	\item STI (\textbf{s}e\textbf{t} - \textbf{i}nterrupt) - turn on interrupt  \pause
    \end{itemize}
  \item Disadvantages  \pause
    \begin{enumerate}
    \item User processes should NOT be able to disable the interrupts;  \pause
      \begin{itemize}
	  \item CLI/STI are both privileged instructions  \pause
	  \end{itemize}
    \item It's not feasible in a multiprocessor system. 
    \end{enumerate}
  \end{itemize}
  \end{frame}

  %% PAGE
  \begin{frame}[fragile]
  \frametitle{TSL and SWAP (1/3)} \pause
  \begin{itemize}
  \item The TSL and SWAP instructions have the following functionalities, respectively:  \pause
  \end{itemize}

\begin{lstlisting}
bool TSL(bool &target)     void SWAP(bool &a, bool &b)
{                          {
  bool rv = target;          bool temp = a;
  target = true;             a = b;
  return rv;                 b= temp;
}                          }
\end{lstlisting}

  \pause

  \begin{itemize}
  \item Bear in mind that TSL and SWAP are executed \emph{atomically}, that is, as one uninterruptible unit. 
  \end{itemize}
\end{frame}

  %% PAGE
  \begin{frame}[fragile]
  \frametitle{TSL and SWAP (2/3)} \pause
  \begin{itemize}
  \item Use TSL or SWAP to TRY to solve race condition  \pause
  \end{itemize}

\begin{lstlisting}
  bool lock = false;               bool lock=false;
  do {                             do {
    // entry section                 // entry section
    while(TSL(lock))                 bool key = true;
      ;                              while(key == true)
                                       SWAP(lock, key);

    CRITICAL SECTION                 CRITICAL SECTION

    // exit section                  // exit section
    lock = false;                    lock = false;

  } while (1);                     } while (1);
\end{lstlisting}

  \pause

  \begin{itemize}
  \item But these two algorithms do NOT satisfy the \textbf{bounded-waiting} requirement. 
  \end{itemize}
\end{frame}

  %% PAGE
  \begin{frame}[fragile]
  \frametitle{TSL and SWAP (3/3)} \pause
  \begin{itemize}
  \item A correct solution using TSL  \pause
  \end{itemize}

\begin{lstlisting}
            bool lock = false, waiting[n] = {false, ..., false};
            do {
              // entry section
              waiting[i] = true;  bool key = true;
              while(waiting[i] && key)
                key = TSL(lock);
              waiting[i] = false;

              CRITICAL SECTION

              // exit section
              int j = (i + 1) % n;
              while((j != i) && !waiting[j])
                j = (j+1) % n;
              if(j == i)    lock = false;
              else          waiting[j] = false;

            } while (1);
\end{lstlisting}

\end{frame}

\subsection{Conclusion}

  %% PAGE
  \begin{frame}
  \frametitle{Conclusion} \pause
  \begin{itemize}
  \item The above solutions have a common disadvantage: \emph{busy waiting}.  \pause
    \begin{itemize}
    \item While a process is in its critical section, any other process tries to enter its critical section must loop continuously in the entry code.  \pause
    \item Busy waiting wastes CPU cycles that some other process might be able to use productively.  \pause
    \end{itemize}
  \item This type of solution is also called a \emph{spinlock}.  \pause
    \begin{itemize}
    \item Because the process ``spins'' while waiting on a lock.  \pause
    \item The spinlocks are \textbf{only} useful in multiprocessor systems.  \pause
      \begin{itemize}
      \item Because no context switch is required if the locks are expected to be held for short times. 
      \end{itemize}
    \end{itemize}
%  \item In addition, these solutions are not easy to generalize to more complex problems.  \pause
  \end{itemize}
  \end{frame}

  %% PAGE
  \begin{frame}
  \frametitle{Questions}
  \begin{itemize}
  \item Any questions? 
  \end{itemize}
  \begin{center}
    \includegraphics[scale=.5]{question}
  \end{center}
  \end{frame}

\section{Semaphore}

\subsection{What's the semaphore?}

  %% PAGE
  \begin{frame}
  \frametitle{Semaphore} \pause
  \begin{itemize}
  \item The above solutions to race condition are not easy to generalize to more complex problems.  \pause
  \item To overcome this difficulty, we can use a synchronization tool called \emph{semaphore}.  \pause
    \begin{itemize}
    \item It's invented by \textit{Edsger Dijkstra} and first used in the \emph{THE} operating system.  \pause
    \end{itemize}
  \item What's the semaphore?  \pause
    \begin{itemize}
    \item A semaphore \emph{S  is an integer variable that, apart from
      initialization, is accessed \textbf{only} through two standard \textbf{atomic} operations: \emph{P}(\emph{down}) and \emph{V}(\emph{up}).}
    \end{itemize}
  \end{itemize}
  \end{frame}

  %% PAGE
  \begin{frame}[fragile]
  \frametitle{Implementation (1/2)} \pause

\begin{lstlisting}
                     typedef struct {
                       int value;

                       /*processes blocked by this semaphore*/
                       struct PCB *L;
                     } semaphore;


void P(semaphore *S) {           void V(semaphore *S) {
 S->value--;                       S->value++;
 if(S->value < 0) {                if(S->value <= 0) {
  Add (curproc) to S->L;             Remove a proc (A) from S->L;

  (curproc)->state=WAITING;          (A)->state=READY;//Wakeup (A)
  scheduler();
 }                                 }
}                                }
\end{lstlisting}

\end{frame}

  %% PAGE
  \begin{frame}
  \frametitle{Implementation (2/2)} \pause
    \begin{itemize}
    \item The magnitude of the ``value'' is the number of resources available ($>$0) or of processes waiting on that semaphore($<$0).  \pause
    \item The \emph{P} and \emph{V} must be executed \textbf{atomically}.  \pause
      \begin{itemize}
      \item In either of two ways:  \pause
        \begin{enumerate}
        \item Disable interrupts in uni-processor systems or  \pause
        \item Spinlocks in multi-processor systems. 
        \end{enumerate}
      \end{itemize}
    \end{itemize}
  \end{frame}

\subsection{Programming interfaces}

  %% PAGE
  \begin{frame}
  \frametitle{Application programming interface} \pause
  \begin{itemize}
  \item Win32  \pause
    \begin{itemize}
    \item CreateSemaphore/CloseHandle  \pause
    \item WaitForSingleObject/ReleaseSemaphore  \pause
    \end{itemize}
  \item POSIX  \pause
    \begin{itemize}
    \item sem\_init/sem\_destroy  \pause
    \item sem\_wait/sem\_post 
    \end{itemize}
  \end{itemize}
  \end{frame}

  %% PAGE
  \begin{frame}
  \frametitle{Questions}
  \begin{itemize}
  \item Any questions? 
  \end{itemize}
  \begin{center}
    \includegraphics[scale=.5]{question}
  \end{center}
  \end{frame}

\subsection{Classic problems of synchronization}

  %% PAGE
  \begin{frame}
  \frametitle{Classic problems of synchronization} \pause
  \begin{itemize}
  \item The producer and consumer problem  \pause
    \begin{itemize}
    \item Explained in the chapter ``Process Management''.  \pause
    \end{itemize}
  \item The readers-writers problem  \pause
    \begin{itemize}
    \item A data object is to be shared among several concurrent processes.  \pause
      \begin{itemize}
      \item Some of them (\emph{readers}) may want \textbf{only} to read the data object, \pause while others (\emph{writers}) may want to update the data object.  \pause
      \end{itemize}
    \item Multiple readers may read the data object simultaneously, but the writers must have exclusive access to the data object.  \pause
    \end{itemize}
  \item The dining-philosophers problem  \pause
    \begin{center}
    \includegraphics[scale=0.4]{v6f7-16}
    \end{center}
  \end{itemize}
  \end{frame}

  %% PAGE
  \begin{frame}
  \frametitle{The producer and consumer problem (1/2)} \pause
  \begin{itemize}
  \item A semaphore \emph{mutex} is used to protect the critical section when accessing the buffer.  \pause
    \begin{itemize}
    \item It's initialized to the value 1.  \pause
    \end{itemize}
  \item The semaphores \emph{empty} and \emph{full  synchronize the producer
    and consumer.} \pause
    \begin{itemize}
    \item \emph{empty} is initialized to the value \emph{BSIZE};  \pause
    \item \emph{full} is initialized to the value 0. 
    \end{itemize}
  \end{itemize}
  \end{frame}

  %% PAGE
  \begin{frame}[fragile]
  \frametitle{The producer and consumer problem (2/2)} \pause
  \begin{minipage}[c]{0.5\textwidth}

\begin{lstlisting}
/*The producer loop*/
do {
  ...
  produce an item;
  ...
  P(&empty);
  P(&mutex);
  ...
  add the item to buffer;
  ...
  V(&mutex);
  V(&full);
} while(1);
\end{lstlisting}

  \end{minipage}%
  \pause
  \begin{minipage}[c]{0.5\textwidth}

\begin{lstlisting}
/*The consumer loop*/
do {
  P(&full);
  P(&mutex);
  ...
  remove an item from buffer;
  ...
  V(&mutex);
  V(&empty);
  ...
  consume the item;
  ...
} while(1);
\end{lstlisting}

  \end{minipage}

\end{frame}

  %% PAGE
  \begin{frame}
  \frametitle{Questions}
  \begin{itemize}
  \item Any questions? 
  \end{itemize}
  \begin{center}
    \includegraphics[scale=.5]{question}
  \end{center}
  \end{frame}

  %% PAGE
  \begin{frame}
  \frametitle{The readers-writers problem (1/2)} \pause
  \begin{itemize}
  \item A semaphore \emph{wrt} is used to protect the shared data object.  \pause
    \begin{itemize}
    \item It's initialized to the value 1.  \pause
    \end{itemize}
  \item An integer \emph{readcount} count the number of readers which is busy reading.  \pause
    \begin{itemize}
    \item \emph{readcount} is initialized to the value 0;  \pause
    \end{itemize}
  \item Another semaphore \emph{mutex} is used to protect the \emph{readcount}.  \pause
    \begin{itemize}
    \item \emph{mutex} is initialized to the value 1. 
    \end{itemize}
  \end{itemize}
  \end{frame}

  %% PAGE
  \begin{frame}[fragile]
  \frametitle{The readers-writers problem (2/2)} \pause
  \begin{minipage}[c]{0.5\textwidth}

\begin{lstlisting}
/*The writer loop*/
do {
    P(&wrt);
    ...
    writing is performed
    ...
    V(&wrt);
} while(1);
\end{lstlisting}

  \end{minipage}%
  \pause
  \begin{minipage}[c]{0.5\textwidth}

\begin{lstlisting}
/*The reader loop*/
do {
    P(&mutex);
    readcount++;
    if(readcount == 1)
      P(&wrt);
    V(&mutex);
    ...
    reading is performed
    ...
    P(&mutex);
    readcount--;
    if(readcount == 0)
      V(&wrt);
    V(&mutex);
} while(1);
\end{lstlisting}

  \end{minipage}

\end{frame}

  %% PAGE
  \begin{frame}
  \frametitle{Questions}
  \begin{itemize}
  \item Any questions? 
  \end{itemize}
  \begin{center}
    \includegraphics[scale=.5]{question}
  \end{center}
  \end{frame}

  %% PAGE
  \begin{frame}[fragile]
  \frametitle{The dining-philosopher problem (1/3)} \pause

\begin{lstlisting}
                 semaphore chopstick[5] = {1, ..., 1};
                 /*philosopher i*/
                 do {
                   ...
                   thinking
                   ...
                   P(&chopstick[i]);
                   P(&chopstick[(i + 1) % 5]);
                   ...
                   eating
                   ...
                   V(&chopstick[(i + 1) % 5]);
                   V(&chopstick[i]);
                 } while(1);
\end{lstlisting}

  \pause

  \begin{itemize}
  \item Is this a correct solution?  \pause
    \begin{itemize}
    \item No. 
    \end{itemize}
  \end{itemize}
\end{frame}

  %% PAGE
  \begin{frame}[fragile]
  \frametitle{The dining-philosophers problem (2/3)} \pause

\begin{lstlisting}
#define N         5
#define LEFT      ((i-1) % N)
#define RIGHT     ((i+1) % N)

enum {THINKING, HUNGRY, EATING} state[N];
semaphore mutex = 1; /*used to protect the `state'*/

semaphore s[N] = {0, ..., 0};

                    void philosopher(int i)
                    {
                      while(1) {
                        think();
                        take_forks(i);
                        eat();
                        put_forks(i);
                      }
                    }
\end{lstlisting}

\end{frame}

  %% PAGE
  \begin{frame}[fragile]
  \frametitle{The dining-philosophers problem (3/3)} \pause

\begin{lstlisting}
                    void test(int i)
                    {
                      if(state[i] == HUNGRY &&
                         state[LEFT] != EATING &&
                         state[RIGHT] != EATING) {
                        state[i] = EATING;
                        V(&s[i]);
                      }
                    }
\end{lstlisting}

  \pause

  \begin{minipage}[c]{0.5\textwidth}
\begin{lstlisting}
        void take_forks(int i)
        {
          P(&mutex);
          state[i] = HUNGRY;
          test(i);
          V(&mutex);
          P(&s[i]);
        }
\end{lstlisting}
    \end{minipage}%   \pause
    \begin{minipage}[c]{0.5\textwidth}
\begin{lstlisting}
void put_forks(int i)
{
  P(&mutex);
  state[i] = THINKING;
  test(LEFT);
  test(RIGHT);
  V(&mutex);
}
\end{lstlisting}
    \end{minipage}

\end{frame}

  %% PAGE
  \begin{frame}
  \frametitle{Questions}
  \begin{itemize}
  \item Any questions? 
  \end{itemize}
  \begin{center}
    \includegraphics[scale=.5]{question}
  \end{center}
  \end{frame}

\subsection{Binary semaphore}

  %% PAGE
  \begin{frame}
  \frametitle{Binary semaphore} \pause
  \begin{itemize}
  \item The semaphore construct described in the previous slides is commonly known as a \emph{counting semaphore}.  \pause
    \begin{itemize}
    \item Since its value can range over an unrestricted domain.  \pause
    \end{itemize}
  \item A \emph{binary semaphore} is a semaphore with an integer value range only between 0 and 1.  \pause
    \begin{itemize}
    \item It can be simpler to implement than a counting semaphore on some hardware architectures.  \pause
    \end{itemize}
  \item A counting semaphore can be implemented using binary semaphores. 
  \end{itemize}
  \end{frame}

  %% PAGE
  \begin{frame}[fragile]
  \frametitle{Implementation of binary semaphore} \pause

\begin{lstlisting}
                 typedef struct {
                   bool flag;

                   /*processes blocked by this binary-semaphore*/
                   struct PCB *L;
                 } binary-semaphore;
\end{lstlisting}

  \pause

  \begin{minipage}[c]{0.5\textwidth}

\begin{lstlisting}
void bP(binary-semaphore *bS) {
  if(bS->flag == true)
    bS->flag = false;
  else {
    Add (curproc) to bS->L;

    (curproc)->state=WAITING;
    scheduler();
  }
}
\end{lstlisting}

  \pause

  \end{minipage}%
  \begin{minipage}[c]{0.5\textwidth}

\begin{lstlisting}
void bV(binary-semaphore *bS) {
  if(bS->L is empty)
    bS->flag = true;
  else {
    Remove a proc (A) from bS->L;

    (A)->state=READY;//Wakeup (A)
  }
}
\end{lstlisting}

  \pause

  \end{minipage}

  \begin{itemize}
    \item The \emph{bP} and \emph{bV} must be executed \textbf{atomically}. 
  \end{itemize}

\end{frame}

  %% PAGE
  \begin{frame}[fragile]
  \frametitle{Implement counting semaphore using binary semaphore} \pause

\begin{lstlisting}
                typedef struct {
                  int value;

                  binary-semaphore bS1 = true,  /*protect `value'*/
                                   bS2 = false; /*synchronization*/
                } semaphore;
\end{lstlisting}

  \pause
  \begin{minipage}[c]{0.5\textwidth}
\begin{lstlisting}
void P(semaphore *S)
{
  bP(&S->bS1);
  S->value--;
  if(S->value < 0) {
    bV(&S->bS1);
    bP(&S->bS2);
  } else
    bV(&S->bS1);
}
\end{lstlisting}
  \end{minipage}%
  \pause
  \begin{minipage}[c]{0.5\textwidth}
\begin{lstlisting}
void V(semaphore *S)
{
  bP(&S->bS1);
  S->value++;
  if(S->value <= 0)
    bV(&S->bS2);
  bV(&S->bS1);
}
\end{lstlisting}

  \end{minipage}

  \pause 

  \begin{itemize}
    \item This implementation of \emph{P} and \emph{V} may \textbf{not} be executed \textbf{atomically}. 
  \end{itemize}

\end{frame}

  %% PAGE
  \begin{frame}
  \frametitle{Questions}
  \begin{itemize}
  \item Any questions? 
  \end{itemize}
  \begin{center}
    \includegraphics[scale=.5]{question}
  \end{center}
  \end{frame}

\iffalse

\subsection{Deadlock and starvation}

  %% PAGE
  \begin{frame}[fragile]
  \frametitle{Deadlock and starvation (1/2)} \pause
  \begin{itemize}
  \item Although semaphores provide a convenient and effective mechanism for process synchronization, their incorrect use can still result in hard-to-detect errors.  \pause
    \begin{itemize}
    \item For example, suppose that two \emph{P}s in the producer loop were reversed in order. That is,   \pause
    \end{itemize}
  \end{itemize}
  \begin{minipage}[c]{0.5\textwidth}

\begin{lstlisting}
do { /*producer*/
  ...
  produce an item;
  ...
  P(&mutex); /*XXX*/
  P(&empty); /*XXX*/
  ...
  add the item to buffer;
  ...
  V(&mutex);
  V(&full);
} while(1);
\end{lstlisting}

  \pause

  \end{minipage}%
  \begin{minipage}[c]{0.5\textwidth}

\begin{lstlisting}
do { /*consumer*/
  P(&full);
  P(&mutex);
  ...
  remove an item from buffer;
  ...
  V(&mutex);
  V(&empty);
  ...
  consume the item;
  ...
} while(1);
\end{lstlisting}

  \end{minipage}
\end{frame}

  %% PAGE
  \begin{frame}
  \frametitle{Deadlock and starvation (2/2)} \pause
  \begin{itemize}
  \item So, what's a deadlock?  \pause
    \begin{itemize}
    \item \emph{A set of processes is deadlocked if each process in the set is waiting for an event that only another process in the set can cause}.  \pause
    \item We will cover the deadlock in the next chapter.  \pause
    \end{itemize}
  \item Another problem related to deadlocks is \emph{starvation} or \emph{indefinite blocking}.  \pause
    \begin{itemize}
    \item A situation where processes wait indefinitely within the semaphore.  \pause
    \item For example, the previous solution to the `readers-writers' problem may result in starvation.  \pause
    \item The starvation can be avoided by using a FCFS resource allocation policy. 
    \end{itemize}
  \end{itemize}
  \end{frame}

  %% PAGE
  \begin{frame}
  \frametitle{Questions}
  \begin{itemize}
  \item Any questions? 
  \end{itemize}
  \begin{center}
    \includegraphics[scale=.5]{question}
  \end{center}
  \end{frame}

\fi

\section{Monitor}

  %% PAGE
  \begin{frame}
  \frametitle{High-level language synchronization constructs} \pause
  \begin{itemize}
  \item As you can see, one subtle error when using semaphores may result in race conditions, deadlocks or other unpredictable and irreproducible behavior.  \pause
  \item To make the life of programmers easier, several high-level language synchronization constructs have been introduced.  \pause
    \begin{itemize}
   \item \emph{Monitors}.  \pause
      \begin{itemize}
      \item It's suggested by Brinch-Hansen in 1973.  \pause
      \end{itemize}
%    \item \emph{Critical regions};  \pause
%      \begin{itemize}
%      \item It's suggested by Hoare and Brinch-Hansen in 1972.  \pause
%      \end{itemize}
    \item And many others... 
    \end{itemize}
  \end{itemize}
  \end{frame}


\iffalse

  %% PAGE
  \begin{frame}
  \frametitle{Critical regions} \pause
  \begin{itemize}
  \item The critical region construct requires that a variable \emph{v} of type \emph{T}, which is to be shared among many processes, be declared as  \pause
  \end{itemize}
  {\centering\emph{v: shared T;}} \pause
  \begin{itemize}
  \item The variable \emph{v} can be accessed only inside a \emph{region} statement of the following form:  \pause
  \end{itemize}
  {\centering\emph{region v when B do S;}} \pause
  \begin{itemize}
  \item When the process tries to execute the \emph{S}, the \emph{B} is evaluated.  \pause
    \begin{itemize}
    \item If the result is \emph{true}, \emph{S} is executed;  \pause
    \item Otherwise, the process relinquishes the CPU and is delayed until \emph{B} becomes \emph{true} and no other process is in the region associated with \emph{v}. 
    \end{itemize}
  \end{itemize}
  \end{frame}

  %% PAGE
  \begin{frame}[fragile]
  \frametitle{Usage of critical regions} \pause
  \begin{itemize}
  \item The producer-consumer problem  \pause
  \end{itemize}

\begin{lstlisting}
                        struct {
                          item pool[n];
                          int count, in, out;
                        } buffer;
\end{lstlisting}
  \pause
  \begin{minipage}[c]{0.5\textwidth}
\begin{lstlisting}

/*producer*/
region buffer when (count < n) {
  pool[in] = nextp;
  in = (in + 1) % n;
  count++;
}
\end{lstlisting}
  \pause
  \end{minipage}%
  \begin{minipage}[c]{0.5\textwidth}
\begin{lstlisting}

/*consumer*/
region buffer when (count > 0) {
  nextc = pool[out];
  out = (out - 1) % n;
  count--;
}
\end{lstlisting}
    \end{minipage}

\end{frame}

  %% PAGE
  \begin{frame}
  \frametitle{Questions}
  \begin{itemize}
  \item Any questions? 
  \end{itemize}
  \begin{center}
    \includegraphics[scale=.5]{question}
  \end{center}
  \end{frame}

\fi

  %% PAGE
  \begin{frame}[fragile]
  \frametitle{Monitor} \pause
  \begin{itemize}
  \item What's a monitor?  \pause
    \begin{itemize}
    \item A monitor is a collection of procedures, variables and data structures that are all grouped together in a special kind of module or package.  \pause
      \begin{minipage}[c]{0.5\textwidth}
      \item Monitors have an important property that makes them useful for achieving mutual exclusion: \emph{only one process can be active in a monitor at any instant}.  \pause
      \end{minipage}%
      \begin{minipage}[c]{0.5\textwidth}

\begin{lstlisting}
monitor producer-consumer {
  int i;
  condition c;

  void produce()
  {
    ...
  }

  void consume()
  {
    ...
  }
}
\end{lstlisting}

      \end{minipage}
    \end{itemize}
  \end{itemize}
\end{frame}

  \subsection{Condition variables}

  %% PAGE
  \begin{frame}
  \frametitle{Condition variables} \pause
  \begin{itemize}
  \item The monitor introduced so far is not enough for a reasonable solution.  \pause
    \begin{itemize}
    \item We also need a way for processes to block when they cannot proceed within a monitor.  \pause
    \end{itemize}
  \item \emph{Condition variables}  \pause
    \begin{itemize}
    \item{Condition variable is defined as a type of variables, which is
      associated with \textbf{only} two operations:} \pause
      \begin{itemize}
      \item \emph{c.wait();} \pause - means that the process invoking it will be suspended until another process invokes  \pause
      \item \emph{c.signal();}  \pause
      \end{itemize}
    \item Note that if no process is suspended, then the \emph{signal} operation has no effect. 
    \end{itemize}
  \end{itemize}
  \end{frame}

  %% PAGE
  \begin{frame}
  \frametitle{Monitor with condition variables} \pause
  \begin{center}
    \includegraphics[scale=.5]{v6f7-21}
  \end{center}
  \end{frame}

  %% PAGE
  \begin{frame}
  \frametitle{What happens after a \emph{c.signal()}?} \pause
  \begin{itemize}
  \item Suppose a process \emph{P} is invoking \emph{c.signal()  and another
    process \emph{Q} is blocked by the condition variable \emph{c}.} \pause
  \item After \emph{P} completed the \emph{c.signal() , it's possible that
    both \emph{P} and \emph{Q} will be active simultaneously within the monitor.} \pause
    \begin{itemize}
    \item This will break the property of the monitor!  \pause
    \end{itemize}
  \item Three possibilities exist:  \pause
    \begin{itemize}
    \item Hoare-style: suspending \emph{P} and letting \emph{Q} run.  \pause
    \item Brinch-Hansen-style: \emph{P} must leave the monitor immediately.  \pause
    \item Mesa-style (Mesa is a programming language): letting \emph{P} run and suspending \emph{Q}. 
    \end{itemize}
  \end{itemize}
  \end{frame}

  \subsection{Monitor solution to the dining-philosopher problem}

  %% PAGE
  \begin{frame}[fragile]
  \frametitle{Monitor solution to the dining-philosopher problem} \pause

\begin{lstlisting}
monitor dp {
  enum {THINKING, HUNGRY, EATING} state[N];
  condition c[N];
\end{lstlisting}

  \begin{minipage}[c]{0.5\textwidth}
\begin{lstlisting}
  void take_forks(int i) {
    state[i] = HUNGRY;
    test(i);
    if(state[i] != EATING)
      c[i].wait();
  }
\end{lstlisting}

  \end{minipage}%
  \begin{minipage}[c]{0.5\textwidth}

\begin{lstlisting}
  void put_forks(int i) {
    state[i] = THINKING;
    test(LEFT);
    test(RIGHT);
  }
\end{lstlisting}
  \end{minipage}

\begin{lstlisting}
  void test(int i) {
    if(state[i] == HUNGRY &&
       state[LEFT] != EATING &&
       state[RIGHT] != EATING) {
      state[i] = EATING;
      c[i].signal();
    }
  }
  void init() {
    for(int i = 0; i < N; i++)
      state[i] = THINKING;
  }
}
\end{lstlisting}

\end{frame}

  %% PAGE
  \begin{frame}
  \frametitle{Questions}
  \begin{itemize}
  \item Any questions? 
  \end{itemize}
  \begin{center}
    \includegraphics[scale=.5]{question}
  \end{center}
  \end{frame}

  \subsection{Language support}

  %% PAGE
  \begin{frame}
 \frametitle{Language support} \pause
 \begin{itemize}
 \item The monitor constructs must be supported by the programming language to be useful.  \pause
   \begin{itemize}
   \item{That is, the compiler must recognize the monitor construct and
     generate codes to support its functionality.} \pause
   \end{itemize}
 \item Example: Java (Mesa-style monitor with only one condition variable)  \pause
     \begin{itemize}
     \item By adding the keyword \emph{synchronized  to a method declaration,
       Java guarantees that once any thread has started executing that method,
       no other thread will be allowed to start executing any other \emph{synchronized} method in that class.} \pause
     \item And Java provides two operations: \emph{wait} and \emph{notify} to block and wakeup the thread. 
     \end{itemize}
 \end{itemize}
  \end{frame}

\iffalse

  %% PAGE
  \begin{frame}
  \frametitle{Language support (2/2)} \pause
% \begin{itemize}\parskip=0pt
% \item Examples  \pause  % FIXME
   \begin{itemize}\parskip=0pt
   \item OpenMP (supports critical-region, www.openmp.org)  \pause
     \begin{itemize}\parskip=0pt
     \item{A specification for a set of compiler directives, library routines,
       and environment variables that can be used to specify shared-memory parallelism in Fortran and C/C++ programs.} \pause
     \item Compilers supporting OpenMP  \pause
       \begin{itemize}\parskip=0pt
       \item Intel C/C++ Compiler, Microsoft Visual Studio 2005, GCC  \pause
       \end{itemize}
     \end{itemize}
   \item Java (supports Mesa-style monitor with only one condition variable)  \pause
     \begin{itemize}\parskip=0pt
     \item By adding the keyword \emph{synchronized  to a method declaration,
       Java guarantees that once any thread has started executing that method,
       no other thread will be allowed to start executing any other \emph{synchronized} method in that class.} \pause
     \item And Java provides two operations: \emph{wait} and \emph{notify} to block and wakeup the thread. 
     \end{itemize}
   \end{itemize}
% \end{itemize}
  \end{frame}

\fi

  %% PAGE
  \begin{frame}
  \frametitle{Questions}
  \begin{itemize}
  \item Any questions? 
  \end{itemize}
  \begin{center}
    \includegraphics[scale=.5]{question}
  \end{center}
  \end{frame}

\section{Relationship of semaphore and monitor}

\iffalse

  %% PAGE
  \begin{frame}
  \frametitle{Relationship of various synchronization constructs (1/2)} \pause
  \begin{itemize}
  \item Synchronization constructs introduced so far is \emph{equivalent} in their functionality.  \pause
    \begin{itemize}
    \item The critical-region can be implemented using semaphore and vice verse.  \pause
    \item The monitor can be implemented using semaphore and vice verse.  \pause
    \item The critical-region can be implemented using monitor and vice verse. 
    \end{itemize}
  \end{itemize}
  \end{frame}

\fi

  %% PAGE
  \begin{frame}
  \frametitle{Relationship of semaphore and monitor} \pause
  \begin{itemize}
  \item Semaphore and monitor are \emph{equivalent} in their functionality.  \pause
    \begin{itemize}
    \item But their use and implementation are quite different.  \pause
    \end{itemize}
  \end{itemize}
  \end{frame}

\iffalse

  %% PAGE
  \begin{frame}[fragile]
  \frametitle{Implement semaphore using critical-region} \pause

\begin{lstlisting}
                        struct {
                          int value;
                        } semaphore;
\end{lstlisting} \pause
  \begin{minipage}[c]{0.5\textwidth}

\begin{lstlisting}
  P(semaphore s) {
    region s when (value > 0) {
      value--;
    }
  }
\end{lstlisting}

  \pause

\end{minipage}%
\begin{minipage}[c]{0.5\textwidth}

\begin{lstlisting}
V(semaphore s) {
  region s when (true) {
    value++;
  }
}
\end{lstlisting}

    \end{minipage}

\end{frame}

  %% PAGE
  \begin{frame}[fragile]
  \frametitle{Implement critical-region using semaphore} \pause

\begin{lstlisting}
 // region v when B do S;
 semaphore mutex, first_delay, second_delay;
 int first_count, second_count;
\end{lstlisting}
  \pause
  \begin{minipage}[c]{0.4\textwidth}

\begin{lstlisting}
P(&mutex);
while(!B) {
  first_count++;
  if(second_count > 0)
    V(&second_delay);
  else
    V(&mutex);
  P(&first_delay);
  first_count--;
  second_count++;
  if(first_count > 0)
    V(&first_delay);
  else
    V(&second_delay);
  P(&second_delay);
  second_count--;
 }
\end{lstlisting} \pause

  \end{minipage}%
  \begin{minipage}[c]{0.2\textwidth}

\begin{lstlisting}
S;
\end{lstlisting}

    \pause
  \end{minipage}%
  \begin{minipage}[c]{0.4\textwidth}

\begin{lstlisting}
 if(first_count > 0)
   V(&first_delay);
 else if (second_count > 0)
   V(&second_delay);
 else
   V(&mutex);
\end{lstlisting}

  \end{minipage}
\end{frame}

\fi

  %% PAGE
  \begin{frame}[fragile]
  \frametitle{Implement semaphore using monitor} \pause

\begin{lstlisting}
                        monitor semaphore {
                          int value;
                          condition c;

                          void P() {
                            value--;
                            if(value < 0)
                              c.wait();
                          }

                          void V() {
                            value++;
                            if(value <= 0)
                              c.signal();
                          }
                        }
\end{lstlisting}

\end{frame}

  %% PAGE
  \begin{frame}[fragile]
  \frametitle{Implement monitor using semaphore} \pause

\begin{lstlisting}
                        semaphore mutex = 1, next = 0;
                        int next_count = 0;

                        // for each condition variable x
                        semaphore x_sem = 1;
                        int x_count = 0;
\end{lstlisting} \pause

  \begin{minipage}[c]{0.4\textwidth}

\begin{lstlisting}
// Mutual exclusion
// within a monitor
P(&mutex);
...
body of F;
...
if(next_count > 0)
  V(&next);
else
  V(&mutex);
\end{lstlisting}
    \pause

  \end{minipage}%
  \begin{minipage}[c]{0.3\textwidth}

\begin{lstlisting}
// x.wait()
x_count++;
if(next_count > 0)
  V(&next);
else
  V(&mutex);
P(&x_sem);
x_count--;
\end{lstlisting}

    \pause

  \end{minipage}%
  \begin{minipage}[c]{0.3\textwidth}
\begin{lstlisting}
// x.signal()
if(x_count > 0) {
  next_count++;
  V(&x_sem);
  P(&next);
  next_count--;
}
\end{lstlisting}

  \end{minipage}
\end{frame}

  %% PAGE
  \begin{frame}
  \frametitle{Questions}
  \begin{itemize}
  \item Any questions? 
  \end{itemize}
  \begin{center}
    \includegraphics[scale=.5]{question}
  \end{center}
  \end{frame}

\section{Conclusion}

  %% PAGE
  \begin{frame}
  \frametitle{Conclusion}
  \begin{center}
	\includegraphics[scale=.5]{psr}
  \end{center}
  \end{frame}

  %% PAGE
  \begin{frame}
  \frametitle{Questions}
  \begin{itemize}
	\item Any questions? 
  \end{itemize}
  \begin{center}
	\includegraphics[scale=.5]{question}
  \end{center}
  \end{frame}

\ifxetexorluatex\else
\end{CJK*}
\fi
\end{document}
